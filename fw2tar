#!/bin/bash
set -eu

BOLD=""
RESET=""
RED=""
GREEN=""
if [ -t 0 ]; then
    # Can only use colors if we're in a terminal
    BOLD=$(tput bold)
    RESET=$(tput sgr0)
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
fi


image="rehosting/fw2tar"

fw2tar_run() {
    local cmd=()
    local maps=()
    local build=false
    local singularity=false
    local verbose=false
    local image="rehosting/fw2tar" # Name of container instance
    local partition_dir=""
    local force=false
    local scratch_dir=""
    local output=""

    # Process each command-line argument
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --wrapper-help)
                echo "Usage: fw2tar [WRAPPER FLAGS] [FLAGS] [FIRMWARE_BLOB] [FINAL_ARCHIVE.tar.gz]"
                echo "Wrapper script for running FW2TAR in a Docker container"
                echo ""
                echo "Wrapper-specific flags may be passed in *before* the fw2tar flags and args. If a value is required, it must be specified immediately after the flag with a space."
                echo "  --build: Build the fw2tar container before running the specified command. If no other arguments are provided, the container will be built and the script will exit."
                echo "  --build-singularity: Build the fw2tar container as a sif."
                echo "  --output: Specify the output file or directory to write the final archive to. If a directory, the archive will be named <input basename>.tar.gz. If the file exists, it will be removed if --force is set."
                echo "  --force: Remove existing output file and scratch directory if they exists."
                echo "  --scratch_dir: Specify a directory to use as a scratch directory"
                echo "  --partition_dir: Specify a directory to produce partition archives into. The directory will be deleted if --force is set."
                echo "  --image: Which image to run. Default: $image"
                echo "  --verbose: Print verbose output for fw2tar wrapper (e.g., filesystem mappings, docker command)"
                echo "  --wrapper-help: this message"
                echo ""
                echo "All other arguments will be passed through to the main fw2tar command in the container."
                echo "For example try:"
                echo "  fw2tar --help"
                echo "  fw2tar ./your_firmware.bin"
                exit 0
                ;;
            --build)
                build=true
                shift
                ;;
            --build-singularity)
                build=true
                singularity=true
                shift
                ;;
            --partition_dir)
                partition_dir="$2"
                shift 2
                ;;
            --scratch_dir)
                scratch_dir="$2"
                shift 2
                ;;
            --output)
                output="$2"
                shift 2
                ;;
            --force)
                force=true
                shift
                ;;
            --image)
                image="$2"
                shift 2
                ;;
            --verbose)
                verbose=true
                shift
                ;;
            *)  # Default case: If no more known options, keep as part of command
                cmd=("$@")
                break
                ;;
        esac
    done

    # If command is empty, parse any un-shifted args into array - probably means we were run with wrapper flags only (i.e., --build)
    if [[ ${#cmd[@]} -eq 0 ]]; then
        cmd=("$@")
    fi

    # If verbose, log all wrapper args and command
    if $verbose; then
        echo "${BOLD}Wrapper args:${RESET}"
        echo "  build: $build"
        echo "  image: $image"
        echo "  verbose: $verbose"
        echo "  fw2tar cmd: ${cmd[*]}"
        echo
    fi

    if $build; then
        echo "Running with container build (--build). Entire container will be rebuilt and tagged as $image."
        # Make sure we have Dockerfile and directory is named fw2tar
        if [ ! -f "Dockerfile" ]; then
            echo "Dockerfile not found in current directory and you requested a container rebuild"
            exit 1
        fi
        # Check if current directory is named fw2tar
        if [ ! "$(basename "$(pwd)")" == "fw2tar" ]; then
            echo "Current directory is not named fw2tar but you requested a container rebuild"
            exit 1
        fi

        if [ ! -z "${SSH_AUTH_SOCK+x}" ]; then
            # Build with ssh
            DOCKER_BUILDKIT=1 docker build --build-arg SSH=1 --ssh default -t $image .
        else
            DOCKER_BUILDKIT=1 docker build -t $image .
        fi

        # --build-singularity
        if $singularity; then
            docker run -v /var/run/docker.sock:/var/run/docker.sock \
                -v $(pwd):/output \
                --privileged -t \
                --rm quay.io/singularity/docker2singularity:v3.9.0 rehosting/fw2tar
            rm -f fw2tar.sif
            mv rehosting_fw2tar*.sif fw2tar.sif

            echo "$image built. Exiting."
            exit 0
        fi

        # If we have no other args, exit 0
        if [[ ${#cmd[@]} -eq 0 ]]; then
            echo "$image built. Exiting as no command was specified."
            exit 0
        fi
    fi

    # Last argument must be the firmware file. This file should already exist
    if [[ -f "${cmd[-1]}" ]]; then
        local arg="${cmd[-1]}"
        local abspath=$(realpath "$arg")
        local host_path=$(dirname "$abspath")
        local guest_path="/host_$(basename "$host_path")"
        maps+=("$host_path:$guest_path")
        firmware_file="/host_$(basename "$host_path")/$(basename "$arg")"
    else
        echo "Fatal error: Firmware file not found: ${cmd[-1]}"
    fi

    # If we have an output
    if [[ ! -z "$output" ]]; then
        # If it's a directory, we'll rename it to <input basename>.tar.gz in the directory
        if [[ -d "$output" ]]; then
            output="$output/$(basename "$firmware_file").rootfs.tar.gz"
        fi

        # Now it should be a file. If it exists, delete if force
        if [[ -e "$output" ]]; then
            if ! $force; then
                echo "Error: Output file already exists: $output"
                echo "Re-run with --force to remove it or delete it yourself first."
                exit 1
            fi
            if $force; then
                echo "Removing output file: $output"
                rm -f "$output"
            fi
        fi

        # If directory doesn't exist, create it
        mkdir -p "$(dirname "$output")"
        local abspath=$(realpath $(dirname "$output"))
        local guest_path="/output"
        maps+=("$abspath:$guest_path")

        # Replace output with /output/<basename $output>
        # so it's valid in the container
        output="/output/$(basename "$output")"
    fi

    # If we have a partition_dir
    if [[ ! -z "$partition_dir" ]]; then
        # If it's already here, make sure it's empty
        if [[ -e "$partition_dir" ]]; then
            if ! $force; then
                echo "Error: Partition directory is not empty: $partition_dir"
                echo "Re-run with --force to remove it or delete it yourself first."
                exit 1
            fi
            if $force; then
                echo "Removing partition directory: $partition_dir"
                rm -rf "$partition_dir"
            fi
        fi
        mkdir -p "$partition_dir"
        local abspath=$(realpath "$partition_dir")
        local guest_path="/partition_dir"
        maps+=("$abspath:$guest_path")
    fi

    # If we have a scratch dir map it in as /tmp
    if [[ ! -z "$scratch_dir" ]]; then
        mkdir -p "$scratch_dir"
        local abspath=$(realpath "$partition_dir")
        local guest_path="/tmp"
        maps+=("$abspath:$guest_path")
    fi

    # Sort mappings by path length
    IFS=$'\n' maps=($(sort -r <<<"${maps[*]}"))
    unset IFS

    if $verbose; then
        echo "${BOLD}Mappings from host paths to guest paths: $RESET"
        for map in "${maps[@]}"; do
            echo "  $map"
        done
        echo
    fi

    # Build Docker command
    docker_cmd=("docker" "run" "--rm")
    docker_cmd+=("-u" "$(id -u):$(id -g)") # XXX will fakeroot be okay?

    # Add mappings to docker command
    for map in "${maps[@]}"; do
        docker_cmd+=("-v" "$map")
    done


    docker_cmd+=("$image")

    local friendly_cmd="fakeroot /usr/local/bin/package_partitions.sh ${firmware_file}"
    docker_cmd+=("fakeroot" "/usr/local/bin/package_partitions.sh")
    docker_cmd+=("${firmware_file}")

    if [[ ! -z "$output" ]]; then
        docker_cmd+=("${output}")
        friendly_cmd+=" ${output}"
    fi

    # If we have partition_dir non-empty, add /partition_dir as final arg
    if [[ ! -z "$partition_dir" ]]; then
        docker_cmd+=("/partition_dir")
        friendly_cmd+=" /partition_dir"
    fi

    if $verbose; then
        echo "${BOLD}Fw2tar command:${RESET}"
        echo "  ${friendly_cmd}"
        echo

        echo "${BOLD}Complete docker commands:${RESET}"
        echo "  ${docker_cmd[*]}"
        echo

        echo "${BOLD}Command output:${RESET}"
    fi

    # Run the Docker command
    "${docker_cmd[@]}"

}

# Main function
main() {
    fw2tar_run "$@"
}
main "$@"
